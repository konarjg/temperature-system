# Exhaustive Review of `Mappers/UserMapper.cs`

The `UserMapper.cs` file, located in the `Domain/Mappers` directory, contains a single static class, `UserMapper`, which holds one extension method, `ToEntity`. This file is responsible for a single, critical task: mapping a `UserCreateData` Data Transfer Object (DTO) into a fully-fledged `User` domain entity. While the `SensorMapper` focused on updating existing entities, this mapper is concerned with creation. The implementation here is particularly insightful, as it cleanly solves the common architectural challenge of handling dependencies, such as a password hashing service, during the mapping process.

The class is declared as `public static class UserMapper`, which is the standard C# convention for a class that will only contain static members, in this case, an extension method. The method `public static User ToEntity(this UserCreateData data, IPasswordSecurity passwordSecurity)` is an extension method on the `UserCreateData` record. This allows for a fluent and intuitive syntax in the calling code (e.g., `creationData.ToEntity(hashingService)`).

The most significant and commendable aspect of this mapper is its method signature. It does not just take the source `UserCreateData` object; it also requires the caller to provide an implementation of the `IPasswordSecurity` interface. This is an elegant and architecturally sound solution to a common problem. The creation of a `User` entity from a `UserCreateData` DTO is not a simple one-to-one property mapping. It involves a business rule: the user's plain-text password (which exists in the `data` DTO) must be securely hashed before it is stored in the `User` entity's `PasswordHash` property. The responsibility for performing this hashing operation belongs to a service that implements `IPasswordSecurity`.

By requiring this service to be passed in as a parameter to the `ToEntity` method, the mapper's design achieves several important goals:
1.  **Dependency Inversion**: The mapper itself does not depend on a concrete implementation of the password hashing service. It depends on the `IPasswordSecurity` abstraction, which is defined in the `Domain` layer. This adheres strictly to the Dependency Inversion Principle.
2.  **Decoupling**: The mapping logic is completely decoupled from the service location or dependency injection container. The mapper does not know or care *how* the caller obtains an instance of `IPasswordSecurity`. It simply states that it *needs* one to do its job. This makes the mapping logic pure and highly portable.
3.  **Testability**: This design makes the `ToEntity` method trivial to unit test. In a test environment, a mock or fake implementation of `IPasswordSecurity` can be passed to the method, allowing the test to verify that the mapping logic correctly calls the `Hash` method on the service and assigns the result to the `PasswordHash` property, all without needing a real hashing algorithm.
4.  **Clarity of Intent**: The method signature makes the dependencies of the mapping operation explicit. It is immediately clear to any developer using this method that a password security service is involved in the creation of a `User` entity.

The body of the `ToEntity` method is a straightforward object instantiation using an object initializer. It creates a `new User` and sets its properties. The `Email` is mapped directly from `data.Email`. The `Role` is set to `Role.Unverified`, which is the correct initial state for a newly registered user before they have completed the email verification process. The crucial line is `PasswordHash = passwordSecurity.Hash(data.Password)`. This line correctly delegates the responsibility of hashing the password to the provided service and assigns the resulting hash to the entity's property.

In conclusion, the `UserMapper.cs` file is an excellent example of a well-designed, architecturally aware mapping component. It cleanly handles a mapping process that involves a dependency on an external service. By passing the dependency as a method parameter, it maintains the purity and testability of the mapping logic while adhering to the principles of Clean Architecture. This approach is superior to alternatives like using a static service locator, which would have tightly coupled the mapper to the DI container and made it difficult to test. This file is of exceptional quality and requires no recommendations for improvement. It is a model for how to handle dependencies within mapping logic.