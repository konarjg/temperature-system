# Exhaustive Review of `Entities/User.cs`

The `User.cs` file, located in the `Domain/Entities` directory, defines the `User` class, which serves as the core domain entity representing a user of the Temperature Monitoring System. As a central entity, its design and implementation are critical to the integrity and clarity of the business domain. This file, though simple in its line count, is dense with excellent design choices that reflect a deep understanding of modern C# and the principles of Clean Architecture.

The class is declared as `public class User`, a standard Plain Old CLR Object (POCO). This is a foundational aspect of its clean design. The `User` entity has no dependencies on any external frameworks. It does not inherit from a base class like `IdentityUser` from ASP.NET Identity, nor is it decorated with data annotation attributes like `[Table]` or `[Key]` from Entity Framework Core. This lack of external dependencies ensures that the core domain model is completely decoupled from any specific implementation details of the database or authentication framework. This separation is crucial for long-term maintainability, as it allows those external frameworks to be changed or updated with minimal to no impact on the core `User` entity itself.

Analyzing the properties of the `User` class reveals a thoughtful and robust design. The `public long Id { get; set; }` property serves as the primary key. Using a `long` instead of an `int` is a good practice for primary keys in systems that could potentially grow to have a very large number of users, as it provides a much larger range of possible values, preventing key exhaustion.

The properties `public required string Email { get; set; }`, `public required string PasswordHash { get; set; }`, and `public required Role Role { get; set; }` make excellent use of the `required` keyword, a feature introduced in C# 11. This keyword is a significant improvement over traditional constructor-based initialization for entities. It enforces at compile time that any code creating a new `User` object *must* initialize these properties using an object initializer. This guarantees that no `User` object can exist in a partially initialized, invalid state where these essential properties are `null`. This greatly enhances the robustness and reliability of the system. The use of the `Role` enum for the `Role` property, rather than a "magic string," is another best practice that provides strong typing, improves readability, and eliminates a common source of bugs related to typos in string values.

One of the most sophisticated features of the `User` entity is the implementation of a soft delete pattern. The `public DateTime? Deleted { get; set; }` property is the cornerstone of this pattern. Instead of physically deleting a user record from the database, which can lead to a loss of historical data and potential referential integrity issues, the system can simply set this `Deleted` property to the UTC timestamp of when the deletion occurred. A `null` value in this property indicates that the user is not deleted. This is a far more robust and flexible approach to data management, especially in systems where auditing and data history are important.

Building upon the soft delete pattern, the most elegant and impactful line in this file is the declaration of the `IsActive` computed property: `public bool IsActive => Deleted == null && Role != Role.Unverified;`. This single expression encapsulates the complete business rule for what it means for a user to be considered "active" and able to use the system. An active user is one who has not been deleted (`Deleted == null`) and has successfully verified their email address (`Role != Role.Unverified`). By placing this logic directly within the `User` entity itself, the design adheres to the principle of high cohesion, keeping the data and the logic that operates on that data together. This is a powerful application of the "Rich Domain Model" concept, where entities are not just passive data containers but can also contain business logic. This approach prevents the `IsActive` logic from being scattered and duplicated across various service classes, which would be a violation of the Don't Repeat Yourself (DRY) principle and a significant maintenance headache. Any change to the definition of an active user now only needs to be made in this one, single location.

In conclusion, the `User.cs` file is a model of excellent domain entity design. It is clean, decoupled, and robust. It leverages modern C# features to enhance its reliability, and it encapsulates business logic effectively through computed properties. It perfectly fulfills its role as a central entity in the domain model and sets a high standard for the other entities in the project. There are no recommendations for improvement for this file; it is an example of best-practice domain-driven design.